{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OFFA - Openid Federation Forward Auth","text":"<p>OFFA offers easy to use OpenID Federation Authentication and Authorisation for existing services. OFFA can be deployed along existing services and handle all OpenID Federation communication for your services.</p> <p>OFFA implements Forward Authentication usable with Traefik, NGINX, Caddy, and maybe other reverse proxies.</p> <p>OFFA also implements Auth MemCookie usable with Apache.</p> <p>See Proxies on how to deploy offa with your favorite reverse proxy.</p>"},{"location":"config/","title":"Config","text":"<p>OFFA is configured through a single configuration file named <code>config.yaml</code>.</p>"},{"location":"config/#config-file-location","title":"Config File Location","text":"<p>OFFA will search for this file at startup at different locations, the first  file that is found will be used. Supported locations are:</p> <ul> <li><code>config.yaml</code></li> <li><code>config/config.yaml</code></li> <li><code>/config/config.yaml</code></li> <li><code>/offa/config/config.yaml</code></li> <li><code>/offa/config.yaml</code></li> <li><code>/data/config/config.yaml</code></li> <li><code>/data/config.yaml</code></li> <li><code>/etc/offa/config.yaml</code></li> </ul>"},{"location":"config/#small-example-config-file","title":"Small Example Config File","text":"<p>The following is a small example config file:</p> config.yaml <pre><code>server:\n\n    logging:\n      access:\n        stderr: true\n      internal:\n        level: info\n        stderr: true\n\n    sessions:\n      ttl: 3600\n      cookie_domain: example.com\n\n    auth:\n      - domain: whoami.example.com\n        require:\n          groups: users\n\n    federation:\n      entity_id: https://offa.example.com\n      trust_anchors:\n        - entity_id: https://ta.example.com\n      authority_hints:\n        - https://ta.example.com\n      logo_uri: https://offa.example.com/static/img/offa-text.svg\n      key_storage: /data\n      use_resolve_endpoint: true\n      use_entity_collection_endpoint: true\n</code></pre>"},{"location":"config/#configuration-sections","title":"Configuration Sections","text":"<ul> <li> Server</li> <li> Logging</li> <li> Federation</li> <li> Auth</li> <li> Sessions</li> <li> <code>debug_auth</code></li> </ul>"},{"location":"config/auth/","title":"Auth","text":"<p>list of Auth Rules required, unless apache is used</p> <p>Under the <code>auth</code> option Auth Rules are configured. Each Auth Rule controls  access to a resource / service / URI.</p> <p>When OFFA receives a request to the forward auth endpoint, the reverse proxy includes  information in the request on which site the user wants to access. OFFA uses  the configured Auth Rules to find a matching rule and evaluate if the user  is authorised to do so or not. (If no rule matches, the user is not authorised).</p> <p>The following options are available for each Auth Rule:</p>"},{"location":"config/auth/#domain","title":"<code>domain</code>","text":"<p>string required, unless <code>domain_regex</code> is given</p> <p>The <code>domain</code> option is used to set the domain that is used to match a  request with the Auth Rule.</p> config.yaml <pre><code>auth:\n    - domain: foobar.example.com\n</code></pre>"},{"location":"config/auth/#domain_regex","title":"<code>domain_regex</code>","text":"<p>string required, unless <code>domain</code> is given</p> <p>The <code>domain_regex</code> option is used to set a regular expression to match the  request's domain with the Auth Rule.</p> <p>The regex must be in the <code>Golang</code> flavor. We recommend https://regex101.com/  to try out your regexes.</p> config.yaml <pre><code>auth:\n    - domain_regex: '^(pub|img)-data\\.example\\.com$'\n</code></pre>"},{"location":"config/auth/#path","title":"<code>path</code>","text":"<p>string optional</p> <p>The <code>path</code> option is used to set an url path that is used to match a request with the Auth Rule. If not set, any path will match.</p> <p>Warning</p> <p>Using the <code>path</code> option requires an exact match. Sub-paths are not  matched. To do so, <code>path_regex</code> must be used.</p> <p>Example</p> <p><code>/private</code> does only match <code>/private</code>, but not <code>/private/</code> or  <code>/private/foo</code>.</p> config.yaml <pre><code>auth:\n    - domain: foobar.example.com\n      path: \"/private\"\n</code></pre>"},{"location":"config/auth/#path_regex","title":"<code>path_regex</code>","text":"<p>string optional</p> <p>The <code>path_regex</code> option is used to set a regular expression to match the request's url path with the Auth Rule.</p> <p>The regex must be in the <code>Golang</code> flavor. We recommend https://regex101.com/ to try out your regexes.</p> config.yaml <pre><code>auth:\n    - domain: foobar.example.com\n      path_regex: '^/private(/?].*)?$'\n</code></pre>"},{"location":"config/auth/#require","title":"<code>require</code>","text":"<p>list optional</p> <p>The <code>require</code> option is used to define authorisation requirements, i.e.  requirements a user has to fulfill in order to get access.</p> <p>The syntax for this option is a bit more complex to allow for flexibility. Generally, the value for <code>require</code> is a list. Each entry is a 'require option', i.e. as soon as one of the options matches the user, the user will be  authorised -- to say it differently: those are logically ORed.</p> <p>If only one option is given the list can be skipped, and it can be given as a  single option.</p> <p>If no options are given, every authenticated user will be authorised.</p>"},{"location":"config/auth/#require-options","title":"<code>require</code> options","text":"<p>Each option entry is a mapping where the keys are OIDC Claim names and the  value is a list of values. The option matches for a user when the user fulfills all specified claims.  Only claims where the value is a string or array of strings can be used. If the claim value is a string, the specified claim value must be equal to  the user claim value in order to fulfill the claim.  If the claim value is an array of strings, the  specified claim values must  be a subset of the user claim values in order to fulfill the claim.</p> <p>If only a single claim value is required (nevertheless if the claim value  type is string or array), it can be specified as a single string (skipping  the list).</p> <p>The following <code>require</code> options are all valid and all equivalent and all  require that users are in the <code>admin</code> group:</p> <code>config.yaml</code> <code>config.yaml</code> <code>config.yaml</code> <code>config.yaml</code> <pre><code>auth:\n  - domain: foobar.example.com\n    require:\n       - groups:\n            - admin\n</code></pre> <pre><code>auth:\n  - domain: foobar.example.com\n    require:\n        groups:\n            - admin\n</code></pre> <pre><code>auth:\n  - domain: foobar.example.com\n    require:\n       - groups: admin\n</code></pre> <pre><code>auth:\n  - domain: foobar.example.com\n    require:\n        groups: admin\n</code></pre> <p>The following is a more complex example with four different require options:</p> <p>config.yaml</p> <pre><code>auth:\n  - domain: foobar.example.com\n    require:\n        - groups: admin\n        - groups:\n            - dev\n            - foobar\n        - sub: john\n        - groups: dev\n          foo: bar  \n</code></pre>"},{"location":"config/auth/#forward_headers","title":"<code>forward_headers</code>","text":"<p>mapping / object see file example optional</p> <p>The <code>forward_headers</code> option is used to specify which HTTP Headers that  should be forwarded to the client / site and also from which OIDC claims the information should be obtained. The <code>forward_headers</code> is a mapping where keys are http header names, and the value are oidc claims.</p> <p>Info</p> <p>OIDC Claims can be given as a single string or a list of strings. If a  list is given OFFA will use the value from the first non-empty claim.</p> <p>Example</p> <p>In the config below <code>X-Forwarded-User</code> will be populated with the  value in <code>preferred_username</code> if that is set, or <code>sub</code> otherwise.</p> <p>The default mapping is as listed in the following <code>config.yaml</code> example.</p> <p>config.yaml</p> <pre><code>auth:\n  - domain: foobar.example.com\n    forward_headers:\n        X-Forwarded-User:\n            - preferred_username\n            - sub\n        X-Forwarded-Groups:\n            - entitlements\n            - groups\n        X-Forwarded-Email: email\n        X-Forwarded-Name: name\n        X-Forwarded-Provider: iss\n        X-Forwarded-Subject: sub\n</code></pre> <p>To forward all oidc claims use the <code>forward_headers_prefix</code> config option.</p>"},{"location":"config/auth/#forward_headers_prefix","title":"<code>forward_headers_prefix</code>","text":"<p>string optional</p> <p>The <code>forward_headers_prefix</code> config option is used to set a prefix for  forwarded headers. When this option is set, all information OFFA obtains is  forwarded via http headers. The name of the headers will be  <code>&lt;prefix&gt;-&lt;claim_name&gt;</code>.</p> config.yaml <pre><code>auth:\n  - domain: foobar.example.com\n    forward_headers_prefix: oidc\n</code></pre>"},{"location":"config/auth/#redirect_status","title":"<code>redirect_status</code>","text":"<p>integer 303 optional</p> <p>If the user needs to be authenticated, OFFA will redirect the browser to the  login page. By default, this uses the HTTP status code  <code>303</code> See Other. However, this might not be supported by the reverse proxy,  (e.g. nginx only accepts <code>401</code> and <code>403</code> responses to authentication  subrequests).  The <code>redirect_status</code> option is used to change the status code for such  redirects.</p> config.yaml <pre><code>auth:\n  - domain: foobar.example.com\n    redirect_status: 401\n</code></pre>"},{"location":"config/debug_auth/","title":"debug_auth","text":"<p>boolean <code>false</code> optional</p> <p>The <code>debug_auth</code> config option is used to enable additional output at the <code>auth</code> endpoint. If set to <code>true</code> OFFA prints additional output for each request to the <code>auth</code> endpoint that includes all received HTTP headers and their values. This can be useful to debug whether the reverse proxy sends the necessary headers.</p> config.yaml <pre><code>debug_auth: true\n</code></pre>"},{"location":"config/federation/","title":"Federation","text":"<p>required</p> <p>Under the <code>federation</code> option configuration related to OpenID Federation  is set.</p>"},{"location":"config/federation/#entity_id","title":"<code>entity_id</code>","text":"<p>uri required</p> <p>The <code>entity_id</code> option is used to set the Federation Entity ID.</p> config.yaml <pre><code>federation:\n    entity_id: https://example.com\n</code></pre>"},{"location":"config/federation/#client_name","title":"<code>client_name</code>","text":"<p>string OFFA - Openid Federation Forward Auth optional</p> <p>The <code>client_name</code> option is used to set a custom client name.</p> config.yaml <pre><code>federation:\n    client_name: My Service\n</code></pre>"},{"location":"config/federation/#logo_uri","title":"<code>logo_uri</code>","text":"<p>uri &lt;entity_id&gt;/static/img/offa-text.svg optional</p> <p>The <code>logo_uri</code> option is used to set a custom logo uri. By default, the OFFA  logo is used.</p> config.yaml <pre><code>federation:\n    logo_uri: https://static.example.com/logo.png\n</code></pre>"},{"location":"config/federation/#scopes","title":"<code>scopes</code>","text":"<p>list of strings recommended</p> <p>The <code>scopes</code> option is used to set which scopes should be requested from the  OpenID Providers.</p> config.yaml <pre><code>federation:\n    scopes:\n        - openid\n        - profile\n        - email\n</code></pre>"},{"location":"config/federation/#trust_anchors","title":"<code>trust_anchors</code>","text":"<p>list required</p> <p>The <code>trust_anchors</code> option is used to specify the Trust Anchors that should  be used.</p> config.yaml <pre><code>federation:\n    trust_anchors:\n        - entity_id: https://ta.example.com\n        - entity_id: https://other-ta.example.org\n          jwks: {...}\n</code></pre> <p>For each list element the following options are defined:</p>"},{"location":"config/federation/#entity_id_1","title":"<code>entity_id</code>","text":"<p>uri required</p> <p>The <code>entity_id</code> of the Trust Anchor.</p>"},{"location":"config/federation/#jwks","title":"<code>jwks</code>","text":"<p>jwks recommended</p> <p>The <code>jwks</code> of the Trust Anchor that was obtained out-of-band. If omitted, it  will be obtained from the Trust Anchor's Entity Configuration and implicitly  trusted. In that case you are trusting TLS.</p> <p>Tip</p> <p>We recommend to provide the <code>jwks</code> as <code>json</code>. <code>json</code> is valid <code>yaml</code> and  can just be included. This way you can pass the whole <code>jwks</code> in a single  line.</p>"},{"location":"config/federation/#authority_hints","title":"<code>authority_hints</code>","text":"<p>list of uris required</p> <p>The <code>authority_hints</code> option is used to specify the Entity IDs of Federation  Entities that are direct superior to OFFA and that issue a statement about OFFA.</p> config.yaml <pre><code>federation:\n    authority_hints:\n        - https://ia.example.com\n</code></pre>"},{"location":"config/federation/#organization_name","title":"<code>organization_name</code>","text":"<p>string optional</p> <p>The <code>organization_name</code> option is used to set the organization name  published in the OpenID Federation Entity Configuration.</p> config.yaml <pre><code>federation:\n    organization_name: Example Organization\n</code></pre>"},{"location":"config/federation/#key_storage","title":"<code>key_storage</code>","text":"<p>directoy path required</p> <p>The <code>key_storage</code> option is used to set a directory where signing keys are  stored. To provide a pre-created signing key to OFFA place it in this  directory. OFFA will use the signing key from the file <code>fed.signing.key</code> as  the federation signing key and the key from the file <code>oidc.signing.key</code> for  the OIDC related signing.</p> <p>Tip</p> <p>Currently only the <code>ES512</code> signing algorithm is supported. OFFA will  support additional keys in the future. But currently the key must use the  <code>P-521</code> curve.</p> <p>Also the private key must be PEM encoded. One does not need to provide a  public key. The public key is derived from the private key.</p> Example Private Key <pre><code>-----BEGIN EC PRIVATE KEY-----\nMIHcAgEBBEIBSH8dWhCVW1eBH6wubSLpdv3kqLpIFk8zkbdtWU43YCKaWa0GhSOG\n88yp6j2FmrXyte7v69FtBvKS08mGWEdD+gugBwYFK4EEACOhgYkDgYYABAHVNodZ\nNZeQcXKnwNqb8dWFcZaAYxRb7Iq3NCRpbKXaaVLS+5+s+Rmvh7BpIuOBMXxCmWe3\nWMB7tQrXYueoaGnvrQA4D9ZSoGBZv0ZXh4w5q6Op2LNya5aEwJejvrSCyRyRqgUZ\njABzf/DoMvsjNfroP5SizcfYeRUB2L4A1Tn1BPbsRQ==\n-----END EC PRIVATE KEY-----\n</code></pre> config.yaml <pre><code>federation:\n    key_storage: /data\n</code></pre>"},{"location":"config/federation/#filter_to_automatic_ops","title":"<code>filter_to_automatic_ops</code>","text":"<p>boolean <code>false</code> optional</p> <p>The <code>filter_to_automatic_ops</code> option is currently unused.</p> config.yaml <pre><code>federation:\n    filter_to_automatic_ops: true\n</code></pre>"},{"location":"config/federation/#trust_marks","title":"<code>trust_marks</code>","text":"<p>list of trust mark configs optional</p> <p>The <code>trust_marks</code> option is used to set Trust Marks that should be published  in the Entity Configuration.</p> config.yaml <pre><code>federation:\n    trust_marks:\n        - trust_mark_type: https://example.com/tm\n          trust_mark_issuer: https://example.com/tmi\n          refresh: true\n          min_lifetime: 300\n          refresh_grace_period: 7200\n</code></pre> <p>Each Trust Mark Config has the following options defined:</p>"},{"location":"config/federation/#trust_mark_type","title":"<code>trust_mark_type</code>","text":"<p>string required</p> <p>The <code>trust_mark_type</code> option sets the Identifier for the type of this Trust  Mark.</p>"},{"location":"config/federation/#trust_mark_issuer","title":"<code>trust_mark_issuer</code>","text":"<p>uri required if <code>trust_mark_jwt</code> not given</p> <p>The <code>trust_mark_issuer</code> option is used to set the Entity ID of the Trust  Mark Issuer of this Trust Mark.</p> <p>Either a Trust Mark JWT (<code>trust_mark_jwt</code>) must be given or the Trust Mark  Issuer (<code>trust_mark_issuer</code>).</p> <p>If this option is given, <code>refresh</code> will be set to <code>true</code> and OFFA  will  obtain Trust Mark JWTs for this Trust Mark Type dynamically.</p>"},{"location":"config/federation/#trust_mark_jwt","title":"<code>trust_mark_jwt</code>","text":"<p>string required if <code>trust_mark_issuer</code> not given</p> <p>The <code>trust_mark_jwt</code> option is used to set a Trust Mark JWT string. This  will be published in the Entity Configuration. If the set Trust Mark JWT expires, it either must be manually updated before  expiration, or automatic refreshing must be enabled through the <code>refresh</code>  option.</p>"},{"location":"config/federation/#refresh","title":"<code>refresh</code>","text":"<p>boolean <code>false</code> optional</p> <p>The <code>refresh</code> option indicates if this Trust Mark should automatically be  refreshed. If set to <code>true</code>, OFFA will fetch a new Trust Mark JWT from  the Trust Mark Issuer before the  old one expires, assuring that always a valid Trust Mark JWT is published in  the Entity Configuration.</p>"},{"location":"config/federation/#min_lifetime","title":"<code>min_lifetime</code>","text":"<p>integer 10 optional</p> <p>The <code>min_lifetime</code> option is used to set a minimum lifetime in seconds on  this Trust Mark. If <code>refresh</code> is set to <code>true</code> OFFA will assure  that the Trust Mark JWT published in the Entity Configuration will not  expire before this lifetime whenever an Entity Configuration is requested.</p>"},{"location":"config/federation/#refresh_grace_period","title":"<code>refresh_grace_period</code>","text":"<p>integer 3600 optional</p> <p>The <code>refresh_grace_period</code> option is used to set a grace period given in  seconds. The default grace period is one hour. If <code>refresh</code> is  set to <code>true</code>, OFFA checks if the Trust Mark expires within the defined grace  period, whenever its Entity Configuration is requested. If the Trust Mark  expires within the grace period the old (but still valid) Trust Mark JWT  will still be included in the Entity Configuration, but in parallel OFFA  will refresh it by requesting a new Trust Mark JWT from the Trust Mark Issuer.</p> <p>This allows OFFA to proactively request Trust Mark JWTs that are expiring  soon in the background.</p>"},{"location":"config/federation/#use_resolve_endpoint","title":"<code>use_resolve_endpoint</code>","text":"<p>boolean <code>false</code> optional</p> <p>The <code>use_resolve_endpoint</code> option indicates if OFFA uses an external  resolver (from the federation) to resolve Trust Chains or does the resolving  by its own. It is generally more performant to rely on an external resolver.</p> config.yaml <pre><code>federation:\n    use_resolve_endpoint: true\n</code></pre>"},{"location":"config/federation/#use_entity_collection_endpoint","title":"<code>use_entity_collection_endpoint</code>","text":"<p>boolean <code>false</code> optional</p> <p>The <code>use_entity_collection_endpoint</code> option indicates if OFFA uses an external entity collection endpoint (from the federation) to collect OpenID Providers  in the federation. The collected providers are used to give the user a  provider selection to they can choose the provider they want to use. It is generally more performant to rely on an external endpoint.</p> config.yaml <pre><code>federation:\n    use_entity_collection_endpoint: true\n</code></pre>"},{"location":"config/federation/#entity_collection_interval","title":"<code>entity_collection_interval</code>","text":"<p>integer 5 optional</p> <p>The <code>entity_collection_interval</code> option defines in which interval OFFA will  query the Entity Collection Endpoint or do entity collection on its own. The  time is given in minutes!</p> config.yaml <pre><code>federation:\n    entity_collection_interval: 60\n</code></pre>"},{"location":"config/logging/","title":"Logging","text":"<p>Under the <code>logging</code> config option the logging behavior and locations can be  configured.</p>"},{"location":"config/logging/#access","title":"<code>access</code>","text":"<p>object recommended</p> <p>Under the <code>access</code> option the http access log can be configured.</p> config.yaml <pre><code>logging:\n    access:\n        dir: /var/log/offa\n        stderr: true\n</code></pre> <p>The following options are available:</p>"},{"location":"config/logging/#dir","title":"<code>dir</code>","text":"<p>directory path optional</p> <p>The <code>dir</code> option is used to configure the directory where the log file  should be stored. If not set, OFFA will not log to file.</p>"},{"location":"config/logging/#stderr","title":"<code>stderr</code>","text":"<p>boolean <code>false</code> optional</p> <p>The <code>stderr</code> option indicates if OFFA logs to <code>stderr</code>.</p>"},{"location":"config/logging/#internal","title":"<code>internal</code>","text":"<p>The <code>internal</code> option is used to configure logging for OFFA's internal  logging, i.e. logging related to what OFFA does.</p> config.yaml <pre><code>logging:\n    internal:\n        dir: /var/log/offa\n        stderr: true\n        level: info\n        smart:\n            enabled: true\n            dir: /var/log/offa/errors\n</code></pre> <p>All configuration options from <code>access</code> also can be used with  <code>internal</code>. In additional the following options can be used:</p>"},{"location":"config/logging/#level","title":"<code>level</code>","text":"<p>enum info optional</p> <p>The <code>level</code> option sets the minimal log level that should be logged.</p> <p>Valid values are:</p> <ul> <li><code>trace</code></li> <li><code>debug</code></li> <li><code>info</code></li> <li><code>warn</code> / <code>warning</code></li> <li><code>error</code></li> <li><code>fatal</code></li> <li><code>panic</code></li> </ul>"},{"location":"config/logging/#smart","title":"<code>smart</code>","text":"<p>Under the <code>smart</code> option 'smart' logging can be enabled and configured.  Smart logging allows to have a higher (less verbose) log level set for  general (internal) logging without loosing valuable debug information in  case errors occure.</p> <p>If smart logging is enabled, the general logs are still done with the level  set through the <code>level</code> option, but if an error occurs a special  error log is created to a dedicated file. This dedicated error log contains  all log entries - including all log levels, also levels that normally woud  not be logged - for that particular request.</p>"},{"location":"config/logging/#enabled","title":"<code>enabled</code>","text":"<p>boolean <code>false</code> optional</p> <p>The <code>enabled</code> option is used to enable smart logging.</p>"},{"location":"config/logging/#dir_1","title":"<code>dir</code>","text":"<p>directory path same as the internal logging dir optional</p> <p>The <code>dir</code> option is used to specify the directory where smart error log  files should be stored. If not set and smart logging is enabled, smart error logs are placed in the  same directory as the regular internal log file.</p>"},{"location":"config/server/","title":"Server","text":"<p>Under the <code>server</code> config option the (http) server can be configured.</p>"},{"location":"config/server/#port","title":"<code>port</code>","text":"<p>integer 15661 optional</p> <p>The <code>port</code> config option is used to set the port at which OFFA starts  the webserver and listens for incoming requests. Will only be used if <code>tls</code> is not used. If <code>tls</code> is enabled port <code>443</code> will be used (and optionally port <code>80</code>).</p> config.yaml <pre><code>server:\n    port: 4242\n</code></pre>"},{"location":"config/server/#tls","title":"<code>tls</code>","text":"<p>Under the <code>tls</code> config option settings related to <code>tls</code> can be configured. It is unlikely that one enables <code>tls</code> since a reverse proxy will be used in  most cases.</p> <p>If <code>tls</code> is enabled port <code>443</code> will be used.</p> config.yaml <pre><code>server:\n    tls:\n        enabled: true\n        redirect_http: true\n        cert: /path/to/cert\n        key: /path/to/key\n</code></pre>"},{"location":"config/server/#enabled","title":"<code>enabled</code>","text":"<p>boolean <code>true</code> optional</p> <p>If set to <code>false</code> <code>tls</code> will be disabled. Otherwise, it will automatically be  enabled, if <code>cert</code> and <code>key</code> are set.</p>"},{"location":"config/server/#redirect_http","title":"<code>redirect_http</code>","text":"<p>boolean <code>true</code> optional</p> <p>The <code>redirect_http</code> option determines if port <code>80</code> should be redirected to  port <code>443</code> or not.</p>"},{"location":"config/server/#cert","title":"<code>cert</code>","text":"<p>file path required for TLS</p> <p>The <code>cert</code> option is set to the tls <code>cert</code> file.</p>"},{"location":"config/server/#key","title":"<code>key</code>","text":"<p>file path required for TLS</p> <p>The <code>key</code> option is set to the tls <code>key</code> file.</p>"},{"location":"config/server/#trusted_proxies","title":"<code>trusted_proxies</code>","text":"<p>list of strings optional</p> <p>The <code>trusted_proxies</code> option is used to configure a list of trusted proxies  by IP address or network range (CIDR notation). If set, only requests from those proxies / networks are accepted at the  forward auth endpoint and other  requests are not accepted. Without setting this option all requests are  accepted.</p> config.yaml <pre><code>server:\n    trusted_proxies:\n        - \"10.0.0.0/8\"\n        - \"172.16.0.0/12\"\n        - \"192.168.0.0/16\"\n        - \"fc00::/7\"\n</code></pre>"},{"location":"config/server/#paths","title":"<code>paths</code>","text":"<p>mapping / object optional</p> <p>The <code>paths</code> option is used to set (custom) uri paths for the different  endpoints.</p> config.yaml <pre><code>server:\n    paths:\n        login: /login\n        forward_auth: /auth\n</code></pre>"},{"location":"config/server/#login","title":"<code>login</code>","text":"<p>string <code>/login</code> optional</p> <p>The <code>login</code> option can be used to set the uri path under which the login  endpoint is served.</p> <p>The login endpoint will serve a webinterface where the user can select an  OpenID Provider and log in. After a successful login, OFFA sets a session  cookie and can redirect the user to the target page.</p> <p>If OFFA is used with apache and AuthMemCookie only  the login endpoint is needed.</p>"},{"location":"config/server/#forward_auth","title":"<code>forward_auth</code>","text":"<p>string <code>/auth</code> optional</p> <p>The <code>forward_auth</code> option can be used to set the uri path under which the  forward auth endpoint is served.</p> <p>The forward auth endpoint will receive auth requests from the reverse proxy.  OFFA checks if the user is authenticated and authorised to access the  requested uri and return the response to the proxy. If the user is not authenticated, the request is redirected to the login  endpoint.</p>"},{"location":"config/server/#web_overwrite_dir","title":"<code>web_overwrite_dir</code>","text":"<p>directory path optional</p> <p>The <code>web_overwrite_dir</code> config option is used to set a base directory path  that contains a directory structure with files that will overwrite embedded  web content.</p> <p>This option allows to overwrite html pages, css, and other web-related  content. See https://github.com/go-oidfed/offa/tree/main/internal/server/web  for the directory structure and content of the embedded files.</p> config.yaml <pre><code>server:\n    web_overwrite_dir: /web\n</code></pre>"},{"location":"config/sessions/","title":"Sessions","text":"<p>required</p> <p>Under the <code>sessions</code> option configuration related to session management can  be changed.</p>"},{"location":"config/sessions/#ttl","title":"<code>ttl</code>","text":"<p>integer 3600 optional</p> <p>The <code>ttl</code> option defines the \"time-to-life\", i.e. the session lifetime.</p> config.yaml <pre><code>sessions:\n    ttl: 86400\n</code></pre>"},{"location":"config/sessions/#redis_addr","title":"<code>redis_addr</code>","text":"<p>string optional</p> <p>The <code>redis_addr</code> option is used to pass a network address where a <code>redis</code>  server can be reached. If set, the <code>redis</code> instance is used for caching. If  not given, an in-memory cache is used.</p> config.yaml <pre><code>sessions:\n    redis_addr: redis:6379\n</code></pre>"},{"location":"config/sessions/#memcached_addr","title":"<code>memcached_addr</code>","text":"<p>string required if apache is used</p> <p>The <code>memcached_addr</code> option is used to pass a network address where a <code>memcached</code> server can be reached. If set, the user claims are stored in the <code>memcached</code>  with the format needed by the apache module AuthMemCookie.</p> <p>Session information is still / also stored in <code>redis</code> or in-memory.</p> config.yaml <pre><code>sessions:\n    memcached_addr: memcached:11211\n</code></pre>"},{"location":"config/sessions/#memcached_claims","title":"<code>memcached_claims</code>","text":"<p>mapping / object see file example optional</p> <p>The <code>memcached_claims</code> option is used to specify which information should be  stored in the <code>memcached</code> and from which OIDC claims the information should  be obtained.</p> <p>Note</p> <p>The following keys are required by AuthMemCookie:</p> <ul> <li>UserName</li> <li>Groups</li> </ul> <p>Info</p> <p>OIDC Claims can be given as a single string or a list of strings. If a  list is given OFFA will use the value from the first non-empty claim.</p> <p>Example</p> <p>In the config below <code>UserName</code> will be populated with the value in  <code>preferred_username</code> if that is set, or <code>sub</code> otherwise.</p> <p>The default mapping is as listed in the following <code>config.yaml</code> example.</p> <p>config.yaml</p> <pre><code>sessions:\n    memcached_claims:\n        UserName:\n            - preferred_username\n            - sub\n        Groups: groups\n        Email: email\n        Name: name\n        GivenName: given_name\n        Provider: iss\n        Subject: sub\n</code></pre>"},{"location":"config/sessions/#cookie_name","title":"<code>cookie_name</code>","text":"<p>string offa-session optional</p> <p>The <code>cookie_name</code> option is used to set the name of the cookie that holds  the session token.</p> config.yaml <pre><code>sessions:\n    cookie_name: offa\n</code></pre>"},{"location":"config/sessions/#cookie_domain","title":"<code>cookie_domain</code>","text":"<p>string required</p> <p>The <code>cookie_domain</code> option is used to set the domain the session cookie is  assigned to protect. This must be the same as the domain OFFA is served on  or a parent domain.</p> <p>Example</p> <p>If OFFA is accessible via the URI <code>https://offa.example.com</code> the domain  should be either <code>offa.example.com</code> or <code>example.com</code>.</p> config.yaml <pre><code>sessions:\n    cookie_domain: example.com\n</code></pre>"},{"location":"proxies/","title":"How to Deploy With","text":"<p>In this section we detail how to deploy OFFA with your reverse proxy.</p> <ul> <li> Traefik</li> <li> NGINX</li> <li> Caddy</li> <li> Apache</li> </ul>"},{"location":"proxies/apache/","title":"Apache","text":"<p>OFFA can be used with apache by using the AuthMemCookie Apache Module.</p> <p>The following example configuration can be used (tweak as needed):</p> <p>We assume the following project layout: <pre><code>\ud83d\udcc1 apache\n\u251c\u2500\u2500 \ud83d\udcc4 Dockerfile #(1)!\n\u2514\u2500\u2500 \ud83d\udcc4 httpd.conf #(2)!\n\ud83d\udcc1 certbot/\n\ud83d\udcc4 docker-compose.yaml #(3)!\n\ud83d\udcc1 offa\n\u2514\u2500\u2500 \ud83d\udcc4 config.yaml #(4)!\n</code></pre></p> <ol> <li><code>apache/Dockerfile</code></li> <li><code>apache/httpd.conf</code></li> <li><code>docker-compose.yaml</code></li> <li><code>offa/config.yaml</code></li> </ol> <code>docker-compose.yaml</code> <code>apache/Dockerfile</code> <code>apache/httpd.conf</code> <code>offa/config.yaml</code> <pre><code>services:\n\n  apache:\n    build:\n      context: ./apache\n    restart: unless-stopped\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./apache/httpd.conf:/usr/local/apache2/conf/extra/httpd-authmem.conf:ro\n      - ./certbot:/etc/letsencrypt:ro\n    depends_on:\n      - whoami\n      - offa\n\n  memcached:\n    image: memcached:alpine\n\n  offa:\n    image: oidfed/offa:main\n    restart: unless-stopped\n    volumes:\n      - ./offa/config.yaml:/config.yaml:ro\n      - ./offa:/data\n    expose:\n      - 15661\n\n  # This would be your service\n  whoami:\n    image: containous/whoami\n    restart: unless-stopped\n</code></pre> <pre><code>FROM httpd:2.4\n\n# Install build dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    apache2-dev \\\n    build-essential \\\n    git \\\n    autoconf \\\n    automake \\\n    libtool \\\n    pkg-config \\\n    curl \\\n    ca-certificates \\\n    libevent-dev \\\n    memcached \\\n    libmemcached-dev \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\nRUN git clone https://github.com/ZenProjects/Apache-Authmemcookie-Module.git /usr/src/authmemcookie &amp;&amp; \\\n    cd /usr/src/authmemcookie &amp;&amp; \\\n    autoconf -f &amp;&amp; \\\n    ./configure --with-libmemcached=/usr --with-apxs=/usr/local/apache2/bin/apxs &amp;&amp; \\\n    make &amp;&amp; \\\n    make install\n\nRUN ls -l /usr/local/apache2/modules\n\nRUN echo \"LoadModule mod_auth_memcookie_module modules/mod_auth_memcookie.so\" \\\n    &gt;&gt; /usr/local/apache2/conf/httpd.conf\nRUN echo \"Include conf/extra/httpd-authmem.conf\" \\\n    &gt;&gt; /usr/local/apache2/conf/httpd.conf\n\nEXPOSE 443\nCMD [\"httpd-foreground\"]\n</code></pre> <pre><code>ServerName whoami.example.com\n\nLoadModule ssl_module modules/mod_ssl.so\nLoadModule proxy_module modules/mod_proxy.so\nLoadModule proxy_http_module modules/mod_proxy_http.so\nLoadModule headers_module modules/mod_headers.so\nLoadModule mod_auth_memcookie_module modules/mod_auth_memcookie.so\nLoadModule rewrite_module modules/mod_rewrite.so\n\nListen 443\n\n&lt;VirtualHost *:443&gt;\n    ServerName whoami.example.com\n\n    SSLEngine on\n    SSLCertificateFile /etc/letsencrypt/live/whoami.example.com/fullchain.pem\n    SSLCertificateKeyFile /etc/letsencrypt/live/whoami.example.com/privkey.pem\n\n    RewriteEngine On\n    RewriteRule ^/autherror$ https://offa.example.com/login?next=https://whoami.example.com [R=303,L]\n\n    ProxyPreserveHost On\n    ProxyPass \"/autherror\" !\n    ProxyPass / http://whoami:80/\n    ProxyPassReverse / http://whoami:80/\n\n\n    &lt;Location /&gt;\n        AuthType Cookie\n        AuthName \"OFFA\"\n    Auth_memCookie_Memcached_Configuration --SERVER=memcached:11211\n    Auth_memCookie_SessionTableSize 32\n    Auth_memCookie_SetSessionHTTPHeader on\n    Auth_memCookie_SetSessionHTTPHeaderPrefix X-Forwarded-\n    Auth_memCookie_CookieName offa-session\n\n    ErrorDocument 401 /autherror\n\n        Require valid-user\n    &lt;/Location&gt;\n\n    &lt;Location \"/autherror\"&gt;\n        Require all granted\n    Satisfy any\n    &lt;/Location&gt;\n\n\n&lt;/VirtualHost&gt;\n\n\n&lt;VirtualHost *:443&gt;\n    ServerName offa.example.com\n\n    SSLEngine on\n    SSLCertificateFile /etc/letsencrypt/live/offa.example.com/fullchain.pem\n    SSLCertificateKeyFile /etc/letsencrypt/live/offa.example.com/privkey.pem\n\n    ProxyPreserveHost On\n    ProxyPass / http://offa:15661/\n    ProxyPassReverse / http://offa:15661/\n&lt;/VirtualHost&gt;\n</code></pre> <pre><code>server:\n\nlogging:\n  access:\n    stderr: true\n  internal:\n    level: info\n    stderr: true\n\nsessions:\n  ttl: 3600\n  cookie_domain: example.com\n  memcached_addr: memcached:11211\n\nfederation:\n  entity_id: https://offa.example.com\n  trust_anchors:\n    - entity_id: https://ta.example.com\n  authority_hints:\n    - https://ta.example.com\n  logo_uri: https://offa.example.com/static/img/offa-text.svg\n  key_storage: /data\n  use_resolve_endpoint: true\n  use_entity_collection_endpoint: true\n</code></pre> <p>For more information about the offa config file, please refer to OFFA Configuration.</p>"},{"location":"proxies/apache/#notes","title":"Notes","text":"<ul> <li>The example setup was tested and works, but there is probably room for   improvements; feel free to submit a Pull Request with improved instructions.</li> <li>The current apache config has a caveat:<ul> <li>When redirecting to the login page, the original request path is not    preserved.    Users will be redirected to the service's root after login.</li> <li>I spent a lot of time to get this working correctly, but could not    figure it out. A Pull Request to fix this issue is very welcomed.</li> </ul> </li> <li>TLS: <ul> <li>To obtain the initial set of certificates run:   <pre><code>docker run --rm -it -p 80:80 -v \"$(pwd)/certbot:/etc/letsencrypt\" certbot/certbot certonly --standalone -d whoami.example.com\ndocker run --rm -it -p 80:80 -v \"$(pwd)/certbot:/etc/letsencrypt\" certbot/certbot certonly --standalone -d offa.example.com\n</code></pre></li> <li>Figure out automatic renewal on your own.</li> </ul> </li> </ul>"},{"location":"proxies/caddy/","title":"Caddy","text":"<p>The following example configuration can be used (tweak as needed):</p> <p>We assume the following project layout:</p> <pre><code>\ud83d\udcc1 caddy\n\u251c\u2500\u2500 \ud83d\udcc4 Caddyfile #(1)!\n\u251c\u2500\u2500 \ud83d\udcc1 config/ \n\u2514\u2500\u2500 \ud83d\udcc1 data/\n\ud83d\udcc4 docker-compose.yaml #(2)!\n\ud83d\udcc1 offa\n\u2514\u2500\u2500 \ud83d\udcc4 config.yaml #(3)!\n</code></pre> <ol> <li><code>caddy/CaddyFile</code></li> <li><code>docker-compose.yaml</code></li> <li><code>offa/config.yaml</code></li> </ol> <code>docker-compose.yaml</code> <code>caddy/Caddyfile</code> <code>offa/config.yaml</code> <pre><code>services:\n  caddy:\n    image: caddy:latest\n    restart: unless-stopped\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./caddy/Caddyfile:/etc/caddy/Caddyfile\n      - ./caddy/data:/data\n      - ./caddy/config:/config\n\n  offa:\n    image: oidfed/offa:main\n    restart: unless-stopped\n    volumes:\n      - ./offa/config.yaml:/config.yaml:ro\n      - ./offa:/data\n\n  # This would be your service\n  whoami:\n    image: containous/whoami\n    restart: unless-stopped\n</code></pre> <pre><code>offa.example.com {\n  reverse_proxy offa:15661\n}\n\nwhoami.example.com {\n    forward_auth offa:15661 {\n        uri /auth\n        copy_headers  X-Forwarded-User X-Forwarded-Groups X-Forwarded-Name X-Forwarded-Email X-Forwarded-Provider X-Forwarded-Subject\n    }\n\n    reverse_proxy whoami:80\n}\n</code></pre> <pre><code>server:\n\nlogging:\n  access:\n    stderr: true\n  internal:\n    level: info\n    stderr: true\n\nsessions:\n  ttl: 3600\n  cookie_domain: example.com\n\nauth:\n  - domain: whoami.example.com\n    require:\n      groups: users\n\nfederation:\n  entity_id: https://offa.example.com\n  trust_anchors:\n    - entity_id: https://ta.example.com\n  authority_hints:\n    - https://ta.example.com\n  logo_uri: https://offa.example.com/static/img/offa-text.svg\n  key_storage: /data\n  use_resolve_endpoint: true\n  use_entity_collection_endpoint: true\n</code></pre> <p>For more information about the offa config file, please refer to OFFA Configuration.</p>"},{"location":"proxies/nginx/","title":"Nginx","text":"<p>The following example configuration can be used (tweak as needed):</p> <p>We assume the following project layout:</p> <pre><code>\ud83d\udcc1 certbot\n\u251c\u2500\u2500 \ud83d\udcc1 conf/\n\u2514\u2500\u2500 \ud83d\udcc1 webroot/\n\ud83d\udcc4 docker-compose.yaml #(1)!\n\ud83d\udcc1 nginx\n\u2514\u2500\u2500 \ud83d\udcc4 nginx.conf  #(2)!\n\ud83d\udcc1 offa\n\u2514\u2500\u2500 \ud83d\udcc4 config.yaml #(3)!\n</code></pre> <ol> <li><code>docker-compose.yaml</code></li> <li><code>nginx/nginx.conf</code></li> <li><code>offa/config.yaml</code></li> </ol> <code>docker-compose.yaml</code> <code>nginx/nginx.conf</code> <code>offa/config.yaml</code> <pre><code>services:\n\n  nginx:\n    image: nginx:stable\n    restart: unless-stopped\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro\n      - ./certbot/webroot:/var/www/certbot\n      - ./certbot/conf:/etc/letsencrypt\n    depends_on:\n      - whoami\n      - offa\n\n\n  certbot:\n    image: certbot/certbot\n    volumes:\n      - ./certbot/webroot:/var/www/certbot\n      - ./certbot/conf:/etc/letsencrypt\n    entrypoint: /bin/sh -c\n    command: &gt;\n      \"certbot certonly --webroot --webroot-path=/var/www/certbot\n       --email your@email.com --agree-tos --no-eff-email\n       -d whoami.example.com -d offa.example.com\"\n\n  offa:\n    image: oidfed/offa:main\n    restart: unless-stopped\n    volumes:\n      - ./offa/config.yaml:/config.yaml:ro\n      - ./offa:/data\n    expose:\n      - 15661\n\n  # This would be your service\n  whoami:\n    image: containous/whoami\n    restart: unless-stopped\n</code></pre> <pre><code>events {}\nhttp {\n\n    # For the certbot challenges\n    server {\n        listen 80;\n        server_name whoami.example.com offa.example.com;\n\n        location /.well-known/acme-challenge/ {\n            root /var/www/certbot;\n        }\n\n        location / {\n            return 301 https://$host$request_uri;\n        }\n    }\n\n    server {\n        listen 443 ssl;\n        server_name offa.example.com;\n\n        ssl_certificate /etc/letsencrypt/live/offa.example.com/fullchain.pem;\n        ssl_certificate_key /etc/letsencrypt/live/offa.example.com/privkey.pem;\n\n        location / {\n            proxy_pass http://offa:15661;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n        }\n    }\n\n    server {\n        listen 443 ssl;\n        server_name whoami.example.com;\n\n        ssl_certificate /etc/letsencrypt/live/whoami.example.com/fullchain.pem;\n        ssl_certificate_key /etc/letsencrypt/live/whoami.example.com/privkey.pem;\n\n        location / {\n            proxy_pass http://whoami:80;\n\n            auth_request     /auth-verify;\n            error_page 401 = @error401;\n            auth_request_set $auth_cookie $upstream_http_set_cookie;\n            add_header Set-Cookie $auth_cookie;\n\n            auth_request_set $auth_redirect $upstream_http_location;\n            auth_request_set $auth_user $upstream_http_x_forwarded_user;\n            auth_request_set $auth_email $upstream_http_x_forwarded_email;\n            auth_request_set $auth_provider $upstream_http_x_forwarded_provider;\n            auth_request_set $auth_subject $upstream_http_x_forwarded_subject;\n            auth_request_set $auth_groups $upstream_http_x_forwarded_groups;\n            auth_request_set $auth_name $upstream_http_x_forwarded_name;\n\n\n            #proxy_set_header Host $host;\n            #proxy_set_header X-Real-IP $remote_addr;\n            #proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            #proxy_set_header X-Forwarded-Proto $scheme;\n            proxy_set_header X-Forwarded-User $auth_user;\n            proxy_set_header X-Forwarded-Email $auth_email;\n            proxy_set_header X-Forwarded-Provider $auth_provider;\n            proxy_set_header X-Forwarded-Subject $auth_subject;\n            proxy_set_header X-Forwarded-Groups $auth_groups;\n            proxy_set_header X-Forwarded-Name $auth_name;\n        }\n\n        location @error401 {\n            internal;\n            add_header Set-Cookie $auth_cookie;\n            return 303 $auth_redirect;\n        }\n\n        location = /auth-verify {\n            internal;\n\n            # Direct internal call to the offa container\n            proxy_pass http://offa:15661/auth;\n\n            # Forward headers\n            proxy_set_header X-Forwarded-Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n            proxy_set_header X-Forwarded-Uri $request_uri;\n\n            proxy_pass_request_body off;\n            proxy_set_header Content-Length \"\";\n\n            proxy_pass_request_headers on;\n            auth_request_set $auth_redirect $upstream_http_location;\n            add_header Location $auth_redirect;\n\n        }\n    }\n}\n</code></pre> <pre><code>server:\n\nlogging:\n  access:\n    stderr: true\n  internal:\n    level: info\n    stderr: true\n\nsessions:\n  ttl: 3600\n  cookie_domain: example.com\n\nauth:\n  - domain: whoami.example.com\n    redirect_status: 401\n    require:\n      groups: users\n\nfederation:\n  entity_id: https://offa.example.com\n  trust_anchors:\n    - entity_id: https://ta.example.com\n  authority_hints:\n    - https://ta.example.com\n  logo_uri: https://offa.example.com/static/img/offa-text.svg\n  key_storage: /data\n  use_resolve_endpoint: true\n  use_entity_collection_endpoint: true\n</code></pre> <p>For more information about the offa config file, please refer to OFFA Configuration.</p>"},{"location":"proxies/nginx/#notes","title":"Notes","text":"<ul> <li>The example setup was tested and works, but there is probably room for    improvements; feel free to submit a Pull Request with improved instructions.</li> <li>The setup includes the tooling to get certbot working. But a proper setup    probably needs some tweaking.<ul> <li>Obtaining the first set of certs might need some manual steps; there    might be a chicken-egg-problem where nginx won't start without a cert,    but certbot requires nginx</li> </ul> </li> </ul>"},{"location":"proxies/traefik/","title":"Traefik","text":"<p>The following example configuration can be used (tweak as needed):</p> <p>We assume the following project layout and an already running <code>traefik</code> (but  the <code>traefik</code> can also be added to the docker compose file):</p> <pre><code>\ud83d\udcc4 docker-compose.yaml #(1)!\n\ud83d\udcc1 offa\n\u2514\u2500\u2500 \ud83d\udcc4 config.yaml #(2)!\n</code></pre> <ol> <li><code>docker-compose.yaml</code></li> <li><code>offa/config.yaml</code></li> </ol> <code>docker-compose.yaml</code> <code>offa/config.yaml</code> <pre><code>services:\n\n  offa:\n    image: oidfed/offa:main\n    restart: unless-stopped\n    volumes:\n      - ./offa/config.yaml:/config.yaml:ro\n      - ./offa:/data\n    expose:\n      - 15661\n    labels:\n      - traefik.enable=true\n      - traefik.port=15661\n      - traefik.http.routers.https-offa.entryPoints=https\n      - traefik.http.routers.https-offa.rule=Host(`offa.example.com`)\n      - traefik.http.routers.https-offa.tls=true\n      - traefik.http.routers.https-offa.tls.certresolver=le\n      - traefik.http.middlewares.offa.forwardauth.address=https://offa.example.com/auth\n      - traefik.http.middlewares.offa.forwardauth.trustForwardHeader=true\n      - traefik.http.middlewares.offa.forwardauth.authResponseHeaders=X-Forwarded-User,X-Forwarded-Groups,X-Forwarded-Name,X-ForwardedEmail,X-Forwarded-Provider,X-Forwarded-Subject\n\n  whoami:\n    image: containous/whoami\n    labels:\n      - traefik.enable=true\n      - traefik.http.routers.https-whoami.rule=Host(`whoami.example.com`)\n      - traefik.http.routers.https-whoami.entryPoints=https\n      - traefik.http.routers.https-whoami.tls=true\n      - traefik.http.routers.https-whoami.tls.certresolver=le\n      - traefik.http.routers.https-whoami.middlewares=offa@docker\n    restart: unless-stopped\n</code></pre> <pre><code>server:\n\nlogging:\n  access:\n    stderr: true\n  internal:\n    level: info\n    stderr: true\n\nsessions:\n  ttl: 3600\n  cookie_domain: example.com\n\nauth:\n  - domain: whoami.example.com\n    redirect_status: 401\n    require:\n      groups: users\n\nfederation:\n  entity_id: https://offa.example.com\n  trust_anchors:\n    - entity_id: https://ta.example.com\n  authority_hints:\n    - https://ta.example.com\n  logo_uri: https://offa.example.com/static/img/offa-text.svg\n  key_storage: /data\n  use_resolve_endpoint: true\n  use_entity_collection_endpoint: true\n</code></pre> <p>For more information about the offa config file, please refer to OFFA Configuration.</p>"}]}